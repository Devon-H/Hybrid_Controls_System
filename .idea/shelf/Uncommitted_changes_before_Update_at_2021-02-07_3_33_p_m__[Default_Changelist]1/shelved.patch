Index: source/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file takes input from the engine stepper motors and other elements\r\nfrom the PCB and PI and decodes the data into information that the GUI back end\r\ncan read and send it through client.py. \r\n\"\"\"\r\n#Throwing strings as communication protocol \r\n#\r\n#assume everything is a dictionary\r\n# \r\n\r\nimport client\r\nimport threading\r\n\r\nHOST = '192.168.0.124' # depends on IP if the server double check this for connection purposes\r\nPORT = 9999 # the port that the server is using\r\n\r\n\r\nclass Receiver:\r\n    \"\"\"\r\n    Receives data from server and passes instructions to controller\r\n    \"\"\"\r\n    def __init__(self, controller):\r\n        \"\"\"\r\n        Initializes the receiver and binds the client to the address, then attempts a connection\r\n        \"\"\"\r\n        self.client = client.Client(HOST, PORT)\r\n        self.ctrl = controller\r\n\r\n\r\n        self.conn_attempt()  # attempts to initalize connection\r\n        self.ctrl.client = self.client\r\n\r\n        self.recieve_thread = threading.Thread(target=self.receive_instructions())  # create the receiver thread\r\n        self.recieve_thread.daemon = False  # this has to do with thread termination\r\n        self.recieve_thread.start()  # start the receiver thread\r\n\r\n    def conn_attempt(self):\r\n        \"\"\"\r\n        attempts to make a connection to a server object\r\n        :return: None if the connection attempt times out, 1 if it is successful\r\n        \"\"\"\r\n        while True:\r\n            try:\r\n                self.client.initialize_connection()  # attempts to make connection\r\n                return # if it works\r\n            except WindowsError as e:  # if it times out try again\r\n                print(e)\r\n\r\n    def receive_instructions(self):\r\n        \"\"\"\r\n        will run in a receiver thread and will constantly check for updates from the server\r\n        :return: Nothing\r\n        \"\"\"\r\n\r\n        while True:\r\n\r\n            self.client.receive_states()  # will hang up on this line until instructions are received\r\n\r\n            while self.client.feedback_queue.qsize() > 0:  # if there are instructions in the queue\r\n                token = self.client.feedback_queue.get(True, 3)  # get them\r\n                param = token[0] # parse the instruction in terms of parameter and state\r\n                state = token[1]\r\n                self.ctrl.set_state(param, state)  # set our dictionary\r\n\r\n    def fail_state(self):\r\n\r\n        self.ctrl.abort()\r\n\r\n        conn_thread = threading.Thread(target=self.conn_attempt())\r\n        conn_thread.daemon = False\r\n        conn_thread.start()\r\n\r\n        while conn_thread.is_alive():\r\n            pass\r\n\r\n\r\nclass Controller:\r\n\r\n    def __init__(self):\r\n        self.states = {\r\n            \"connected\": False,\r\n            \"igniter\": False,\r\n            \"MEV\": \"closed\",\r\n            \"N2OV\": \"closed\",\r\n            \"N2O\": \"closed\",\r\n            \"N2\": \"closed\",\r\n            \"NCV\": \"closed\",\r\n            \"RV\": \"closed\",\r\n            \"VV\": \"closed\",\r\n            \"abort\": False,\r\n            \"run\": False\r\n        }\r\n\r\n        self.funcs = {\r\n            \"igniter\": \"set_igniter\",\r\n            \"MEV\": \"set_MEV\",\r\n            \"N2OV\": \"set_N20V\",\r\n            \"N2O\": \"set_N20\",\r\n            \"N2\": \"set_N2\",\r\n            \"NCV\": \"set_NCV\",\r\n            \"RV\": \"set_RV\",\r\n            \"VV\": \"set_VV\",\r\n            \"abort\": \"abort\",\r\n            \"run\": \"run\"\r\n        }\r\n\r\n        self.client = None\r\n\r\n    def write_to_serial(self, command):\r\n        self.state_update()\r\n        #some code that writes to serial\r\n\r\n    def state_update(self):\r\n\r\n        for i in self.states:\r\n            self.client.send_states(f\"{i} {self.states[i]}\")\r\n\r\n    def set_state(self, param, state):\r\n        func = getattr('self', f\"{self.funcs[param]}\")\r\n        func(state)\r\n\r\n    def set_igniter(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_MEV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N20V(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N20(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N2(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_NCV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_RV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_VV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def abort(self, param):\r\n        self.write_to_serial()\r\n\r\n    def run(self, param):\r\n        self.write_to_serial()\r\n\r\n\r\n\r\n\r\ndef main():\r\n    pass\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source/controller.py b/source/controller.py
--- a/source/controller.py	
+++ b/source/controller.py	
@@ -10,6 +10,12 @@
 
 import client
 import threading
+from serial import Serial
+
+baud_rate = 115200          # In the arduino .ino file, Serial.begin(baud_rate)
+serial_port = "dev/ttyUSB0" # Something similar to this. It will depend what usb port the arduino is connected to
+ser = Serial(serial_port, baud_rate)
+
 
 HOST = '192.168.0.124' # depends on IP if the server double check this for connection purposes
 PORT = 9999 # the port that the server is using
@@ -37,7 +43,7 @@
     def conn_attempt(self):
         """
         attempts to make a connection to a server object
-        :return: None if the connection attempt times out, 1 if it is successful
+        :return: Nothing
         """
         while True:
             try:
@@ -60,25 +66,25 @@
                 token = self.client.feedback_queue.get(True, 3)  # get them
                 param = token[0] # parse the instruction in terms of parameter and state
                 state = token[1]
-                self.ctrl.set_state(param, state)  # set our dictionary
+
+                if param == "connected" and state == "False": # checks if connection is ending
+                    self.fail_state()
+                    return
+
+                self.ctrl.write_to_serial((param, state))  # send the command to our controller, notice we are sending
+                # a tuple, this is on purpose, its a stylistic choice
 
     def fail_state(self):
 
         self.ctrl.abort()
-
-        conn_thread = threading.Thread(target=self.conn_attempt())
-        conn_thread.daemon = False
-        conn_thread.start()
-
-        while conn_thread.is_alive():
-            pass
+        self.recieve_thread.join()
+        self.client.end_connection()
 
 
 class Controller:
 
     def __init__(self):
         self.states = {
-            "connected": False,
             "igniter": False,
             "MEV": "closed",
             "N2OV": "closed",
@@ -87,70 +93,40 @@
             "NCV": "closed",
             "RV": "closed",
             "VV": "closed",
-            "abort": False,
-            "run": False
         }
 
-        self.funcs = {
-            "igniter": "set_igniter",
-            "MEV": "set_MEV",
-            "N2OV": "set_N20V",
-            "N2O": "set_N20",
-            "N2": "set_N2",
-            "NCV": "set_NCV",
-            "RV": "set_RV",
-            "VV": "set_VV",
-            "abort": "abort",
-            "run": "run"
+        self.abort_states = {
+            "igniter": False,
+            "MEV": "closed",
+            "N2OV": "open",
+            "N2O": "closed",
+            "N2": "closed",
+            "NCV": "closed",
+            "RV": "open",
+            "N2V": "open",
         }
 
         self.client = None
 
     def write_to_serial(self, command):
-        self.state_update()
-        #some code that writes to serial
+
+        ser.writelines(f'{command[0]} {command[1]}'.encode())  # Write stuff to arduino
+
+    def read_from_serial(self):
+
+        command = ser.readline().decode().split
+        self.states[command[0]] = command[1]  # update our dictionary
+        self.state_update()  # send updated dictionary back to server
+
 
     def state_update(self):
 
         for i in self.states:
             self.client.send_states(f"{i} {self.states[i]}")
 
-    def set_state(self, param, state):
-        func = getattr('self', f"{self.funcs[param]}")
-        func(state)
-
-    def set_igniter(self, param):
-        self.write_to_serial()
-
-    def set_MEV(self, param):
-        self.write_to_serial()
-
-    def set_N20V(self, param):
-        self.write_to_serial()
-
-    def set_N20(self, param):
-        self.write_to_serial()
-
-    def set_N2(self, param):
-        self.write_to_serial()
-
-    def set_NCV(self, param):
-        self.write_to_serial()
-
-    def set_RV(self, param):
-        self.write_to_serial()
-
-    def set_VV(self, param):
-        self.write_to_serial()
-
-    def abort(self, param):
-        self.write_to_serial()
-
-    def run(self, param):
-        self.write_to_serial()
-
-
-
+    def abort(self):
+        for i in self.abort_states:
+            self.write_to_serial((i, self.abort_states[i]))
 
 def main():
     pass
