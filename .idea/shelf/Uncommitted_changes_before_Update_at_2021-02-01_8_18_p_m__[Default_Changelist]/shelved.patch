Index: source/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file takes input from the engine stepper motors and other elements\r\nfrom the PCB and PI and decodes the data into information that the GUI back end\r\ncan read and send it through client.py. \r\n\"\"\"\r\n#Throwing strings as communication protocol \r\n#\r\n#assume everything is a dictionary\r\n# \r\n\r\nimport client\r\nimport threading\r\n\r\nHOST = '192.168.0.124' # depends on IP if the server double check this for connection purposes\r\nPORT = 9999 # the port that the server is using\r\n\r\n\r\nclass Receiver:\r\n    \"\"\"\r\n    Receives data from server and passes instructions to controller\r\n    \"\"\"\r\n    def __init__(self, controller):\r\n        \"\"\"\r\n        Initializes the receiver and binds the client to the address, then attempts a connection\r\n        \"\"\"\r\n        self.client = client.Client(HOST, PORT)\r\n        self.ctrl = controller\r\n\r\n\r\n        self.conn_attempt()  # attempts to initalize connection\r\n        self.ctrl.client = self.client\r\n\r\n        self.recieve_thread = threading.Thread(target=self.receive_instructions())  # create the receiver thread\r\n        self.recieve_thread.daemon = False  # this has to do with thread termination\r\n        self.recieve_thread.start()  # start the receiver thread\r\n\r\n    def conn_attempt(self):\r\n        \"\"\"\r\n        attempts to make a connection to a server object\r\n        :return: None if the connection attempt times out, 1 if it is successful\r\n        \"\"\"\r\n        while True:\r\n            try:\r\n                self.client.initialize_connection()  # attempts to make connection\r\n                return # if it works\r\n            except WindowsError as e:  # if it times out try again\r\n                print(e)\r\n\r\n    def receive_instructions(self):\r\n        \"\"\"\r\n        will run in a receiver thread and will constantly check for updates from the server\r\n        :return: Nothing\r\n        \"\"\"\r\n\r\n        while True:\r\n\r\n            self.client.receive_states()  # will hang up on this line until instructions are received\r\n\r\n            while self.client.feedback_queue.qsize() > 0:  # if there are instructions in the queue\r\n                token = self.client.feedback_queue.get(True, 3)  # get them\r\n                param = token[0] # parse the instruction in terms of parameter and state\r\n                state = token[1]\r\n                self.ctrl.set_state(param, state)  # set our dictionary\r\n\r\n    def fail_state(self):\r\n\r\n        self.ctrl.abort()\r\n\r\n        conn_thread = threading.Thread(target=self.conn_attempt())\r\n        conn_thread.daemon = False\r\n        conn_thread.start()\r\n\r\n        while conn_thread.is_alive():\r\n            pass\r\n\r\n\r\nclass Controller:\r\n\r\n    def __init__(self):\r\n        self.states = {\r\n            \"connected\": False,\r\n            \"igniter\": False,\r\n            \"MEV\": \"closed\",\r\n            \"N2OV\": \"closed\",\r\n            \"N2O\": \"closed\",\r\n            \"N2\": \"closed\",\r\n            \"NCV\": \"closed\",\r\n            \"RV\": \"closed\",\r\n            \"VV\": \"closed\",\r\n            \"abort\": False,\r\n            \"run\": False\r\n        }\r\n\r\n        self.funcs = {\r\n            \"igniter\": \"set_igniter\",\r\n            \"MEV\": \"set_MEV\",\r\n            \"N2OV\": \"set_N20V\",\r\n            \"N2O\": \"set_N20\",\r\n            \"N2\": \"set_N2\",\r\n            \"NCV\": \"set_NCV\",\r\n            \"RV\": \"set_RV\",\r\n            \"VV\": \"set_VV\",\r\n            \"abort\": \"abort\",\r\n            \"run\": \"run\"\r\n        }\r\n\r\n        self.client = None\r\n\r\n    def write_to_serial(self, command):\r\n        self.state_update()\r\n        #some code that writes to serial\r\n\r\n    def state_update(self):\r\n\r\n        for i in self.states:\r\n            self.client.send_states(f\"{i} {self.states[i]}\")\r\n\r\n    def set_state(self, param, state):\r\n        func = getattr('self', f\"{self.funcs[param]}\")\r\n        func(state)\r\n\r\n    def set_igniter(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_MEV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N20V(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N20(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_N2(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_NCV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_RV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def set_VV(self, param):\r\n        self.write_to_serial()\r\n\r\n    def abort(self, param):\r\n        self.write_to_serial()\r\n\r\n    def run(self, param):\r\n        self.write_to_serial()\r\n\r\n\r\n\r\n\r\ndef main():\r\n    pass\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source/controller.py b/source/controller.py
--- a/source/controller.py	(revision 9ebcffdf0c4e5c26cc0824b8d06843a8d3087088)
+++ b/source/controller.py	(date 1612123802631)
@@ -10,6 +10,12 @@
 
 import client
 import threading
+from serial import Serial
+
+baud_rate = 115200          # In the arduino .ino file, Serial.begin(baud_rate)
+serial_port = "dev/ttyUSB0" # Something similar to this. It will depend what usb port the arduino is connected to
+ser = Serial(serial_port, baud_rate)
+
 
 HOST = '192.168.0.124' # depends on IP if the server double check this for connection purposes
 PORT = 9999 # the port that the server is using
@@ -37,7 +43,7 @@
     def conn_attempt(self):
         """
         attempts to make a connection to a server object
-        :return: None if the connection attempt times out, 1 if it is successful
+        :return: Nothing
         """
         while True:
             try:
@@ -60,25 +66,25 @@
                 token = self.client.feedback_queue.get(True, 3)  # get them
                 param = token[0] # parse the instruction in terms of parameter and state
                 state = token[1]
-                self.ctrl.set_state(param, state)  # set our dictionary
+
+                if param == "connected" and state == "False": # checks if connection is ending
+                    self.fail_state()
+                    return
+
+                self.ctrl.write_to_serial((param, state))  # send the command to our controller, notice we are sending
+                # a tuple, this is on purpose, its a stylistic choice
 
     def fail_state(self):
 
         self.ctrl.abort()
-
-        conn_thread = threading.Thread(target=self.conn_attempt())
-        conn_thread.daemon = False
-        conn_thread.start()
-
-        while conn_thread.is_alive():
-            pass
+        self.recieve_thread.join()
+        self.client.end_connection()
 
 
 class Controller:
 
     def __init__(self):
         self.states = {
-            "connected": False,
             "igniter": False,
             "MEV": "closed",
             "N2OV": "closed",
@@ -87,70 +93,34 @@
             "NCV": "closed",
             "RV": "closed",
             "VV": "closed",
-            "abort": False,
-            "run": False
         }
 
-        self.funcs = {
-            "igniter": "set_igniter",
-            "MEV": "set_MEV",
-            "N2OV": "set_N20V",
-            "N2O": "set_N20",
-            "N2": "set_N2",
-            "NCV": "set_NCV",
-            "RV": "set_RV",
-            "VV": "set_VV",
-            "abort": "abort",
-            "run": "run"
+        self.abort_states = {
+            "igniter": False,
+            "MEV": "closed",
+            "N2OV": "closed",
+            "N2O": "closed",
+            "N2": "closed",
+            "NCV": "closed",
+            "RV": "closed",
+            "VV": "closed",
         }
 
         self.client = None
 
     def write_to_serial(self, command):
-        self.state_update()
-        #some code that writes to serial
+        ser.writelines(f'{command[0]} {command[1]}')  # Write stuff to arduino
+        self.states[command[0]] = command[1]  # update our dictionary
+        self.state_update()  # send updated dictionary back to server
 
     def state_update(self):
 
         for i in self.states:
             self.client.send_states(f"{i} {self.states[i]}")
 
-    def set_state(self, param, state):
-        func = getattr('self', f"{self.funcs[param]}")
-        func(state)
-
-    def set_igniter(self, param):
-        self.write_to_serial()
-
-    def set_MEV(self, param):
-        self.write_to_serial()
-
-    def set_N20V(self, param):
-        self.write_to_serial()
-
-    def set_N20(self, param):
-        self.write_to_serial()
-
-    def set_N2(self, param):
-        self.write_to_serial()
-
-    def set_NCV(self, param):
-        self.write_to_serial()
-
-    def set_RV(self, param):
-        self.write_to_serial()
-
-    def set_VV(self, param):
-        self.write_to_serial()
-
-    def abort(self, param):
-        self.write_to_serial()
-
-    def run(self, param):
-        self.write_to_serial()
-
-
-
+    def abort(self):
+        for i in self.abort_states:
+            self.write_to_serial((i, self.abort_states[i]))
 
 def main():
     pass
Index: source/hybrid_test_backend.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt5 import QtWidgets, uic, QtCore, QtGui\r\nfrom PyQt5.QtCore import QTimer, QDateTime, QThread, pyqtSignal, Qt, QRect\r\nfrom PyQt5.QtWidgets import QFileDialog\r\nimport sys\r\nimport server\r\nHOST = '192.168.0.106'\r\nPORT = 9999\r\n\r\n\r\nclass GetStatusThread(QThread):\r\n\r\n    \"\"\"\r\n    Thread that is in charge of constantly checking to see if we have recieved any data from the client\r\n    If so, read the data and change our states\r\n    \"\"\"\r\n\r\n    # the status_signal is what the GetStatusThread uses to communicate with the rest of the program\r\n    status_signal = pyqtSignal(object)\r\n\r\n    def __init__(self, server_ob, states):\r\n        \"\"\"\r\n        Initializes the thread\r\n        :param server_ob: the object representing the connection to the server\r\n        :param states: the dictionary of states\r\n        \"\"\"\r\n        # self.schematic.setPixmap(QtGui.QPixmap(\"source\\images\\MULE-1_PID_for_GUI.png\"))\r\n        # self.resize(self.schematic.width(), self.schematic.height())\r\n        self.client_server = server_ob\r\n        self.states = states\r\n        QThread.__init__(self)\r\n\r\n    def run(self):\r\n        \"\"\"\r\n        Runs in a thread to constantly provide status updates from the client\r\n        Is in charge of updating the status messages shown on the GUI\r\n        \"\"\"\r\n        while True:\r\n\r\n            try:\r\n                self.client_server.receive_states() # Will hang up on this line until it receives something from client\r\n            except server.NoConnection:\r\n                return\r\n            param = None\r\n            state = None\r\n            while self.client_server.feedback_queue.qsize() > 0:    # clears the queue and pops output to GUI\r\n\r\n                try:\r\n                    token = self.client_server.feedback_queue.get(True, 3)\r\n                    param = token[0]\r\n                    state = token[1]\r\n                except server.queue.Empty: # if we have a mix up with our queue something bad has happened\r\n                    self.status_signal.emit(f'Failed to parse arguments: {param}, {state}')\r\n                    continue\r\n                except IndexError:\r\n                    self.status_signal.emit(f'Failed to parse arguments: {param}, {state}')\r\n                    self.status_signal.emit(f'Reattempting...')\r\n                    continue\r\n\r\n                if param not in self.states.keys():  # checks to make sure parameter is valid\r\n                    self.status_signal.emit(f'Invalid parameter {param}')\r\n                    continue\r\n\r\n                self.states[param] = state\r\n                self.status_signal.emit(f'{param} {state}')\r\n\r\n\r\nclass MainWindow(QtWidgets.QMainWindow):\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Load the UI Page. uic is the thing that lets us use a .ui file\r\n        # This only works if the .ui file is in the same directory\r\n        super(MainWindow, self).__init__(*args, **kwargs)\r\n        uic.loadUi('hybrid_test_gui.ui', self)\r\n        \r\n        self.setup_buttons()\r\n        self.setup_timers()\r\n        #Temperately used \"global\" variables for toggle buttons TODO: change to states\r\n        self.toggle_auto = False\r\n        self.toggle_man = False\r\n        self.client_server = None\r\n        self.status_thread = None\r\n\r\n        ############################ STATES ###############################\r\n        # These will get updated by the GUI if the user clicks a button or\r\n        # if the server changes something. Any time one of these is changed,\r\n        # it will be sent over to the server using send_states()\r\n        self.system_states = {\r\n            \"connected\" : False,\r\n            \"igniter\" : False,\r\n            \"MEV\" : \"closed\",\r\n            \"N2OV\" : \"closed\",\r\n            \"N2O\" : \"closed\",\r\n            \"N2\" : \"closed\",\r\n            \"NCV\" : \"closed\",\r\n            \"RV\" : \"closed\",\r\n            \"VV\" : \"closed\",\r\n            \"abort\" : False,\r\n            \"run\" : False\r\n        }\r\n        \r\n\r\n    ################################ SETUP ####################################\r\n\r\n    def setup_buttons(self):\r\n        # Alright so basically since there is not a \"loop\" to put methods in that\r\n        # you want to update based on things that have changed in the GUI,\r\n        # PyQt has these things called signals and slots. They let you connect\r\n        # changes or \"signals\" of objects in the GUI to methods.\r\n\r\n        # For instance we can connect_btn is a QPushButton from QT Designer, \r\n        # which has a signal \"clicked\". We can \"connect\" this to a method that\r\n        # we want to run when the button is clicked. \r\n        self.connect_btn.clicked.connect(self._connect_btn)\r\n\r\n        # We do this for every button in the GUI. Each button gets a corresponding\r\n        # method that has the same name as the button but with an _ in front\r\n        \r\n        # To add a new button:\r\n            # Add the button to the GUI in QT Designer\r\n            # Give it a nice name\r\n            # Add a new line to this method in the form \"self.button_name.clicked.connect(self._button_name)\"\r\n            # Add a new method in below setup_button_etc of the form \"def _button_name(self):\"\r\n            # Any code in that method will be run when the button is clicked!\r\n        self.disconnect_btn.clicked.connect(self._disconnect_btn)\r\n        # MANUAL CHECKBOXES\r\n            # checkboxes used \".isChecked\" to singal a change in state. \r\n            # Each function connected will check the current state of the switch.   \r\n        self.ignitor_man.valueChanged.connect(self._Ignitor_btn)\r\n        self.mev_man.valueChanged.connect(self._MEV_btn)\r\n        self.n2o_vent_man.valueChanged.connect(self._N2OV_btn)\r\n        self.n2o_flow_man.valueChanged.connect(self._N2O_btn)\r\n        self.n2_flow_man.valueChanged.connect(self._N2_btn)\r\n        self.n2_vent_man.valueChanged.connect(self._N2V_btn)\r\n        self.ncv_man.valueChanged.connect(self._NCV_btn)\r\n        self.purge_vent_man.valueChanged.connect(self._RV_btn)\r\n        # AUTO CHECKBOXES\r\n        self.purge_vent_auto.valueChanged.connect(self._RV_btn)\r\n        self.n2o_vent_auto.valueChanged.connect(self._N2OV_btn)\r\n        self.n2o_flow_auto.valueChanged.connect(self._N2O_btn)\r\n        self.n2_flow_auto.valueChanged.connect(self._N2_btn)\r\n        self.n2_vent_auto.valueChanged.connect(self._N2V_btn)\r\n        self.abort_btn.clicked.connect(self._abort_btn)\r\n        self.vent_all_btn.clicked.connect(self._vent_all_btn)\r\n        self.fire_btn.clicked.connect(self._run_btn)\r\n        #SYSTEM PARAMETERS\r\n        self.test_used.clicked.connect(self._load_checked)\r\n        self.load_test_btn.clicked.connect(self._open_file)\r\n        self.man_btn.clicked.connect(self._man_btn)\r\n        self.auto_btn.clicked.connect(self._auto_btn)\r\n\r\n        # self.test_used\r\n\r\n\r\n    def setup_timers(self):\r\n        # See setup_buttons() for more details. We're doing the same\r\n        # thing but first creating a timer and connecting it's .timeout signal\r\n        # to a method that runs some code.\r\n\r\n        # Timer to update the \"Date/Time\" QlineEdit with current system time\r\n        self.date_time_timer = QTimer()\r\n        self.date_time_timer.timeout.connect(self._date_time)\r\n        self.date_time_timer.start(1000)\r\n\r\n    ############################# BACKEND ###############################\r\n\r\n\r\n    # Create an instance of the Server class. This is what will allow our\r\n    # communication between the backend and the server   \r\n    def _connect_btn(self):\r\n        # Get our IP from the box on the GUI, instantiate a Server with it\r\n        # PORT is hard coded in at the top of the file, if you change PORT here, you must also change\r\n        # it in client\r\n        if self.client_server is not None:\r\n            if self.client_server.client is not None:\r\n                self.add_system_status(\"Connection already active\")\r\n                return\r\n\r\n        if self.lineEdit_IPaddress.text() == \"\":   # this if statement checks to see if we haven't entered an IP\r\n            self.add_system_status(\"Invalid IP\")\r\n            return\r\n        try:\r\n            self.client_server = server.Server(self.lineEdit_IPaddress.text(), PORT)\r\n            self.client_server.initialize_connection()\r\n        except Exception as e:\r\n            print(f'line 171 {e}')\r\n\r\n\r\n        # Attempt connection to the Server on the rPi\r\n        if(self.client_server.client != None):\r\n            self.add_system_status(f\"Connection Successful on HOST:PORT {self.client_server.HOST}:{self.client_server.PORT}\") \r\n            self.system_states[\"connected\"] = True\r\n            self.send_states(\"connected True\")\r\n            try:\r\n                self.status_thread = GetStatusThread(self.client_server, self.system_states)\r\n                self.status_thread.status_signal.connect(self.add_system_status)\r\n                self.status_thread.start()\r\n            except Exception as e:\r\n                print(f'line 184 {e}')\r\n        else:\r\n            self.add_system_status(\"Connection Unsuccessful. Is the IP address correct?\")\r\n            self.client_server = None\r\n\r\n    # Disconnect from the Server on the rPi\r\n    def _disconnect_btn(self):\r\n        try:\r\n            self.send_states(\"connected false\")\r\n            self.client_server.end_connection()\r\n            self.add_system_status(\"Disconnection Successful\")\r\n            self.system_states[\"connected\"] = False\r\n        \r\n        # This error throws if you try to disconnect before making a connection\r\n        except AttributeError:\r\n            self.add_system_status(\"Disconnection Unsuccessful. Does the connection exist?\")\r\n\r\n   \r\n   \r\n    # All these functions do the basically the same thing\r\n        # Add a message to the \"System Status\" panel on the GUI.\r\n        # Update our system_states dictionary\r\n        # Send the new state over the client_server Server object\r\n    def _igniter_btn_on(self):#TODO: ignitor needs reworking talk to connor... \r\n        self.add_system_status(\"Igniting\")\r\n        self.system_states[\"igniter\"] = True\r\n        self.send_states(\"igniter True\")\r\n       \r\n    def _igniter_btn_off(self):\r\n        self.add_system_status(\"Un-igniting?\")\r\n        self.system_states[\"igniter\"] = False\r\n        self.send_states(\"igniter False\")\r\n\r\n    def _MEV_btn_off(self):  \r\n        self.add_system_status(\"Closing MEV\")\r\n        self.system_states[\"MEV\"] = \"closed\"\r\n        self.send_states(\"MEV closed\")\r\n\r\n    def _MEV_btn_on(self):\r\n        self.add_system_status(\"Opening MEV\")\r\n        self.system_states[\"MEV\"] = \"open\"\r\n        self.send_states(\"MEV open\")\r\n\r\n    def _N2OV_btn_off(self):\r\n        self.add_system_status(\"Closing N2O Vent\")\r\n        self.system_states[\"N2OV\"] = \"closed\"\r\n        self.send_states(\"N2OV closed\")\r\n        \r\n    def _N2OV_btn_on(self):\r\n        self.add_system_status(\"Opening N2O Vent\")\r\n        self.system_states[\"N2OV\"] = \"open\"\r\n        self.send_states(\"N2OV open\")\r\n\r\n    def _N2O_btn_off(self):\r\n        self.add_system_status(\"Closing N2O Valve\")\r\n        self.system_states[\"N2O\"] = \"closed\"\r\n        self.send_states(\"N2O closed\")\r\n\r\n    def _N2O_btn_on(self):\r\n        self.add_system_status(\"Opening N2O Valve\")\r\n        self.system_states[\"N2O\"] = \"open\"\r\n        self.send_states(\"N2O open\")\r\n\r\n    def _N2_btn_off(self):\r\n        self.add_system_status(\"Closing N2 Valve\")\r\n        self.system_states[\"N2\"] = \"closed\"\r\n        self.send_states(\"N2 closed\")\r\n\r\n    def _N2_btn_on(self):\r\n        self.add_system_status(\"Opening N2 Valve\")\r\n        self.system_states[\"N2\"] = \"open\"\r\n        self.send_states(\"N2 open\")\r\n\r\n    def _N2V_btn_off(self):\r\n        self.add_system_status(\"Closing N2 Vent Valve\")\r\n        self.system_states[\"N2V\"] = \"closed\"\r\n        self.send_states(\"N2V closed\")\r\n\r\n    def _N2V_btn_on(self):\r\n        self.add_system_status(\"Opening N2 Vent Valve\")\r\n        self.system_states[\"N2V\"] = \"open\"\r\n        self.send_states(\"N2 open\")\r\n\r\n    def _NCV_btn_off(self):\r\n        self.add_system_status(\"Closing NC Valve\")\r\n        self.system_states[\"NCV\"] = \"closed\"\r\n        self.send_states(\"NCV closed\")\r\n\r\n    def _NCV_btn_on(self):\r\n        self.add_system_status(\"Opening NC Valve\")\r\n        self.system_states[\"NCV\"] = \"open\"\r\n        self.send_states(\"NCV open\")\r\n\r\n    def _RV_btn_off(self):\r\n        self.add_system_status(\"Closing Relief Valve\")\r\n        self.system_states[\"RV\"] = \"closed\"\r\n        self.send_states(\"RV closed\")\r\n\r\n    def _RV_btn_on(self):\r\n        self.add_system_status(\"Opening Relief Valve\")\r\n        self.system_states[\"RV\"] = \"open\"\r\n        self.send_states(\"RV open\")\r\n\r\n    def _VV_btn_off(self):\r\n        self.add_system_status(\"Closing Vent Valve\")\r\n        self.system_states[\"VV\"] = \"closed\"\r\n        self.send_states(\"VV closed\")\r\n\r\n    def _VV_btn_on(self):\r\n        self.add_system_status(\"Opening Vent Valve\")\r\n        self.system_states[\"VV\"] = \"open\"\r\n        self.send_states(\"VV open\")\r\n\r\n    def _abort_btn(self):\r\n        self.add_system_status(\"ABORTING\")\r\n        self.system_states[\"abort\"] = True\r\n        self.send_states(\"abort True\")\r\n\r\n    def _run_btn(self):\r\n        self.add_system_status(\"RUNNING\")\r\n        self.system_states[\"run\"] = True\r\n        self.send_states(\"run True\")\r\n    #auto and manual toggle buttons\r\n    #The filling and Venting portions will  \r\n    #All these functions check the current state of the checkbox and run the corresponding function above.\r\n    # def _igniter_btn_toggle(self):\r\n    #     if self.igniter_man.isChecked() == True:\r\n    def _Ignitor_btn(self):\r\n        if self.ignitor_man.value() == 1:\r\n            self._igniter_btn_on()\r\n        else:\r\n            self._igniter_btn_off()\r\n    def _MEV_btn(self):\r\n        if self.mev_man.value() == 1:\r\n            self._MEV_btn_on()\r\n        else:\r\n            self._MEV_btn_off()\r\n\r\n    def _N2OV_btn(self):\r\n        if self.n2o_vent_man.value() == 1 or self.n2o_vent_auto.value() == 1:\r\n            self._N2OV_btn_on()\r\n        else:\r\n            self._N2OV_btn_off()\r\n    def _N2O_btn(self):\r\n        if self.n2o_flow_man.value() == 1 or self.n2o_flow_auto.value() == 1:\r\n            self._N2O_btn_on()\r\n        else:\r\n            self._N2O_btn_off()\r\n   \r\n    def _N2V_btn(self):\r\n        if self.n2_vent_man.value() == 1 or self.n2_vent_auto.value() == 1:\r\n            self._N2V_btn_on()\r\n        else:\r\n            self._N2V_btn_off() \r\n    def _N2_btn(self):\r\n        if self.n2_flow_man.value() == 1 or self.n2_flow_auto.value() == 1:\r\n            self._N2_btn_on()\r\n        else:\r\n            self._N2_btn_off()\r\n    \r\n    def _NCV_btn(self):\r\n        if self.ncv_man.value() == 1:\r\n            self._NCV_btn_on()\r\n        else:\r\n            self._NCV_btn_off()\r\n    def _RV_btn(self):\r\n        if self.purge_vent_auto.value() == 1 or self.purge_vent_man.value() == 1:\r\n            self._RV_btn_on()\r\n        else:\r\n            self._RV_btn_off()\r\n\r\n    #auto control buttons\r\n    #MAIN control buttons\r\n    def _vent_all_btn(self): #TODO: might need to change\r\n        self.add_system_status(\"Vent Valve (vent all)\")\r\n        toggle = self.system_states[\"VV\"]\r\n        toggle = not bool(toggle)\r\n        self.system_states[\"VV\"] = toggle\r\n        self.send_states(f\"{toggle} Vent Valve (vent all)\")\r\n\r\n    def _run_btn(self):\r\n        self.add_system_status(\"RUNNING\")\r\n        self.system_states[\"run\"] = True\r\n        self.send_states(\"run True\")\r\n\r\n    def _abort_btn(self):\r\n        self.add_system_status(\"ABORTING\")\r\n        self.system_states[\"abort\"] = True\r\n        self.send_states(\"abort True\")\r\n    \r\n\r\n    #SYSTEM PARAMETERS \r\n        # MANUAL and AUTO Buttons\r\n        #these buttons will disable the other control category \r\n        #if Manual is toggled on then the auto buttons will be disabled\r\n    def _man_btn(self):\r\n        \r\n        if self.toggle_man == False:\r\n            self.toggle_man = True\r\n            self.toggle_auto = False\r\n            self.man_btn.setStyleSheet(\"QPushButton { border:0.1em solid black; }\")\r\n            self._disable_man()\r\n            self.man_con_label.setStyleSheet(\"QLabel{color: #7f849a;}\")\r\n\r\n        else:\r\n            self.toggle_man = False\r\n            self.man_btn.setStyleSheet(\"QPushButton { border:0.1em solid yellow;  }\")\r\n            self._enable_man()\r\n            self.man_con_label.setStyleSheet(\"QLabel{color: yellow;}\")\r\n\r\n\r\n    def _auto_btn(self):\r\n        if self.toggle_auto == False:\r\n            self.toggle_auto = True\r\n            self.toggle_man = False\r\n            self.auto_btn.setStyleSheet(\"QPushButton { border:0.1em solid black;}\")\r\n            self._disable_auto()\r\n            self.auto_con_label.setStyleSheet(\"QLabel{color: #7f849a;}\")\r\n\r\n        else:\r\n            self.toggle_auto = False\r\n            self.auto_btn.setStyleSheet(\"QPushButton {border:0.1em solid yellow; }\")\r\n            self._enable_auto()\r\n            self.auto_con_label.setStyleSheet(\"QLabel{color: yellow;}\")\r\n\r\n    #DISABLEING and ENABLING CONTROL BOXES\r\n    # disable manual control box\r\n    def _disable_man(self):\r\n        self.ignitor_man.setEnabled(False)\r\n        self.n2_flow_man.setEnabled(False)\r\n        self.n2o_flow_man.setEnabled(False)\r\n        self.purge_vent_man.setEnabled(False)\r\n        self.mev_man.setEnabled(False)\r\n        self.n2_vent_man.setEnabled(False)\r\n        self.n2o_vent_man.setEnabled(False)\r\n        self.ncv_man.setEnabled(False)\r\n        \r\n        self.ignitor_man.setValue(0)\r\n        self.n2_flow_man.setValue(0)\r\n        self.n2o_flow_man.setValue(0)\r\n        self.purge_vent_man.setValue(0)\r\n        self.mev_man.setValue(0)\r\n        self.n2_vent_man.setValue(0)\r\n        self.n2o_vent_man.setValue(0)\r\n        self.ncv_man.setValue(0)\r\n    # Enable manual control box\r\n    def _enable_man(self):\r\n        self.ignitor_man.setEnabled(True)\r\n        self.n2_flow_man.setEnabled(True)\r\n        self.n2o_flow_man.setEnabled(True)\r\n        self.purge_vent_man.setEnabled(True)\r\n        self.mev_man.setEnabled(True)\r\n        self.n2_vent_man.setEnabled(True)\r\n        self.n2o_vent_man.setEnabled(True)\r\n        self.ncv_man.setEnabled(True)\r\n\r\n    #disable auto control box\r\n    def _disable_auto(self):\r\n        self.n2o_flow_auto.setEnabled(False)\r\n        self.n2_flow_auto.setEnabled(False)\r\n        self.n2o_vent_auto.setEnabled(False)\r\n        self.n2_vent_auto.setEnabled(False)\r\n        self.purge_vent_auto.setEnabled(False)\r\n        self.abort_btn.setEnabled(False)\r\n        self.fire_btn.setEnabled(False)\r\n        self.vent_all_btn.setEnabled(False)\r\n\r\n        self.n2o_flow_auto.setValue(0)\r\n        self.n2_flow_auto.setValue(0)\r\n        self.n2o_vent_auto.setValue(0)\r\n        self.n2_vent_auto.setValue(0)\r\n        self.purge_vent_auto.setValue(0)\r\n\r\n    #Enable auto control box\r\n    def _enable_auto(self):\r\n        self.n2o_flow_auto.setEnabled(True)\r\n        self.n2_flow_auto.setEnabled(True)\r\n        self.n2o_vent_auto.setEnabled(True)\r\n        self.n2_vent_auto.setEnabled(True)\r\n        self.purge_vent_auto.setEnabled(True)\r\n        self.abort_btn.setEnabled(True)\r\n        self.fire_btn.setEnabled(True)\r\n        self.vent_all_btn.setEnabled(True)\r\n\r\n    #Load test\r\n    def _open_file(self):\r\n        #see strain gauge UI for documentation\r\n        file_name, filter_ = QFileDialog.getOpenFileName(self, 'Open File', \"Data files (*.txt)\")\r\n\r\n        self.file_path.setText(file_name) \r\n\r\n    def _load_checked(self):#TODO: add actual functionality, disable params if checked\r\n        #run file commands... or something like that.\r\n        if self.test_used.isChecked() == True:\r\n            self.add_system_status(\"load file is checked\")\r\n            self.burn_duration.setEnabled(False)\r\n            self.ignitor_delay.setEnabled(False)\r\n            self.mev_open.setEnabled(False)\r\n            self.mev_open_speed.setEnabled(False)\r\n        else:\r\n            self.add_system_status(\"load file is unchecked\")\r\n            self.burn_duration.setEnabled(True)\r\n            self.ignitor_delay.setEnabled(True)\r\n            self.mev_open.setEnabled(True)\r\n            self.mev_open_speed.setEnabled(True)\r\n            \r\n    #Edit line parameters\r\n    # TODO: Figure out where to load this data to\r\n    # def _duration(self):\r\n        # #use \"self.burn_duration.text()\" to use the information from the edit line. \r\n\r\n    # def _mev_open(self):\r\n        # #use \"self.mev_open.text()\" to use the information from the edit line. \r\n\r\n    # def _delay(self):\r\n        # #use \"self.ignitor_delay.text()\" to use the information from the edit line. \r\n\r\n    # def _mev_open_speed(self):\r\n        # #use \"self.mev_open_speed.text()\" to use the information from the edit line. \r\n\r\n\r\n\r\n\r\n\r\n    # The \"System Status\" box on the gui is a QPlainTextEdit that we can add\r\n    # text to. It will contain a log of all the things that have happened in the gui\r\n    def add_system_status(self, msg):\r\n        self.statusbox.appendPlainText(msg)\r\n\r\n    ############################### METHODS ON TIMERS ##################################\r\n    def _date_time(self):\r\n        self.date_time.setText(QDateTime.currentDateTime().toString())\r\n\r\n    ############################### SERVER COMMUNICATION METHODS ##################################\r\n\r\n    def send_states(self, msg):\r\n        \"\"\"\r\n        Sends a message from the server to the client\r\n\r\n        msg: The message being sent, message is of the form \"system_property state\"\r\n             for example \"abort True\"\r\n        \"\"\"\r\n        if self.client_server is None:\r\n            self.add_system_status(\"ERROR[1]: Connection Not Initialized\")\r\n            return\r\n        try:\r\n            self.client_server.send_states(msg)\r\n        except WindowsError as e:\r\n            self.add_system_status(f\"ERROR[1]: Connection Not Initialized {e}\")\r\n            self.client_server = None\r\n\r\ndef main():\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    main = MainWindow()\r\n    main.show()\r\n    sys.exit(app.exec_())\r\n\r\nif __name__ == '__main__':      \r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source/hybrid_test_backend.py b/source/hybrid_test_backend.py
--- a/source/hybrid_test_backend.py	(revision 9ebcffdf0c4e5c26cc0824b8d06843a8d3087088)
+++ b/source/hybrid_test_backend.py	(date 1612123802621)
@@ -38,13 +38,13 @@
 
             try:
                 self.client_server.receive_states() # Will hang up on this line until it receives something from client
-            except server.NoConnection:
-                return
+            except server.NoConnection:  # means that no connection has been established
+                return  # end the thread
             param = None
             state = None
             while self.client_server.feedback_queue.qsize() > 0:    # clears the queue and pops output to GUI
 
-                try:
+                try:  # reads tuples off the queue
                     token = self.client_server.feedback_queue.get(True, 3)
                     param = token[0]
                     state = token[1]
@@ -53,15 +53,14 @@
                     continue
                 except IndexError:
                     self.status_signal.emit(f'Failed to parse arguments: {param}, {state}')
-                    self.status_signal.emit(f'Reattempting...')
                     continue
 
                 if param not in self.states.keys():  # checks to make sure parameter is valid
                     self.status_signal.emit(f'Invalid parameter {param}')
                     continue
 
-                self.states[param] = state
-                self.status_signal.emit(f'{param} {state}')
+                self.states[param] = state  # sets our dictionary
+                self.status_signal.emit(f'{param} {state}') # sends the new data to the GUI
 
 
 class MainWindow(QtWidgets.QMainWindow):
@@ -74,9 +73,6 @@
         
         self.setup_buttons()
         self.setup_timers()
-        #Temperately used "global" variables for toggle buttons TODO: change to states
-        self.toggle_auto = False
-        self.toggle_man = False
         self.client_server = None
         self.status_thread = None
 
@@ -94,6 +90,8 @@
             "NCV" : "closed",
             "RV" : "closed",
             "VV" : "closed",
+            "toggle_auto" : False,
+            "toggle_man" : False,
             "abort" : False,
             "run" : False
         }
@@ -148,9 +146,6 @@
         self.man_btn.clicked.connect(self._man_btn)
         self.auto_btn.clicked.connect(self._auto_btn)
 
-        # self.test_used
-
-
     def setup_timers(self):
         # See setup_buttons() for more details. We're doing the same
         # thing but first creating a timer and connecting it's .timeout signal
@@ -169,41 +164,36 @@
     def _connect_btn(self):
         # Get our IP from the box on the GUI, instantiate a Server with it
         # PORT is hard coded in at the top of the file, if you change PORT here, you must also change
-        # it in client
-        if self.client_server is not None:
-            if self.client_server.client is not None:
-                self.add_system_status("Connection already active")
-                return
+        # it in controller.py
+
+        # Checks to see if a connection is already active
+        if self.system_states['connected']:
+            self.add_system_status("Connection already active")
+            return
 
         if self.lineEdit_IPaddress.text() == "":   # this if statement checks to see if we haven't entered an IP
             self.add_system_status("Invalid IP")
             return
-        try:
+        try:  # Attempt connection to the Client on the rPi
             self.client_server = server.Server(self.lineEdit_IPaddress.text(), PORT)
-            self.client_server.initialize_connection()
-        except Exception as e:
-            print(f'line 171 {e}')
+            self.client_server.initialize_connection()  # will hang on this line until the client is connected
+        except server.InvalidIp:
+            self.add_system_status("Invalid IP")
+            return
 
-
-        # Attempt connection to the Server on the rPi
-        if(self.client_server.client != None):
-            self.add_system_status(f"Connection Successful on HOST:PORT {self.client_server.HOST}:{self.client_server.PORT}") 
-            self.system_states["connected"] = True
-            self.send_states("connected True")
-            try:
-                self.status_thread = GetStatusThread(self.client_server, self.system_states)
-                self.status_thread.status_signal.connect(self.add_system_status)
-                self.status_thread.start()
-            except Exception as e:
-                print(f'line 184 {e}')
-        else:
-            self.add_system_status("Connection Unsuccessful. Is the IP address correct?")
-            self.client_server = None
+        # should only hit this code if connection successfully made
+        self.add_system_status(f"Connection Successful on HOST:PORT {self.client_server.HOST}:{self.client_server.PORT}")
+        self.system_states["connected"] = True
+
+        # Start looking for updates from the client
+        self.status_thread = GetStatusThread(self.client_server, self.system_states)
+        self.status_thread.status_signal.connect(self.add_system_status)
+        self.status_thread.start()
 
-    # Disconnect from the Server on the rPi
+    # Disconnect from the client on the rPi
     def _disconnect_btn(self):
         try:
-            self.send_states("connected false")
+            self.send_states("connected False")
             self.client_server.end_connection()
             self.add_system_status("Disconnection Successful")
             self.system_states["connected"] = False
@@ -218,8 +208,8 @@
         # Add a message to the "System Status" panel on the GUI.
         # Update our system_states dictionary
         # Send the new state over the client_server Server object
-    def _igniter_btn_on(self):#TODO: ignitor needs reworking talk to connor... 
-        self.add_system_status("Igniting")
+
+    def _igniter_btn_on(self):
         self.system_states["igniter"] = True
         self.send_states("igniter True")
        
@@ -317,11 +307,11 @@
         self.add_system_status("RUNNING")
         self.system_states["run"] = True
         self.send_states("run True")
-    #auto and manual toggle buttons
-    #The filling and Venting portions will  
-    #All these functions check the current state of the checkbox and run the corresponding function above.
-    # def _igniter_btn_toggle(self):
-    #     if self.igniter_man.isChecked() == True:
+
+    # auto and manual toggle buttons
+    # The filling and Venting portions will
+    # All these functions check the current state of the checkbox and run the corresponding function above.
+
     def _Ignitor_btn(self):
         if self.ignitor_man.value() == 1:
             self._igniter_btn_on()
@@ -537,14 +527,10 @@
         msg: The message being sent, message is of the form "system_property state"
              for example "abort True"
         """
-        if self.client_server is None:
-            self.add_system_status("ERROR[1]: Connection Not Initialized")
-            return
         try:
             self.client_server.send_states(msg)
         except WindowsError as e:
             self.add_system_status(f"ERROR[1]: Connection Not Initialized {e}")
-            self.client_server = None
 
 def main():
     app = QtWidgets.QApplication(sys.argv)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"BranchesTreeState\">\r\n    <expand>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"LOCAL_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"GROUP_NODE:origin\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n    </expand>\r\n    <select />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"91da95a7-87d1-4534-8d3d-902312f1a94d\" name=\"Default Changelist\" comment=\"Added the state update method and thread.\">\r\n      <change beforePath=\"$PROJECT_DIR$/source/controller.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/source/controller.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1jDU4BfFwYv3GNyZTSjfa4inNB6\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"ASKED_SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\" />\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.controller\">\r\n    <configuration name=\"client\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"D:\\Python\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/source\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/source/client.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"controller\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Hybrid_Controls_System\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/source\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/source/controller.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"hybrid_test_backend\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"D:\\Python\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/source\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/source/hybrid_test_backend.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"server\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"D:\\Python\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/source\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/source/server.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"tester\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"D:\\Python\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/source\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/source/tester.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.client\" />\r\n      <item itemvalue=\"Python.hybrid_test_backend\" />\r\n      <item itemvalue=\"Python.server\" />\r\n      <item itemvalue=\"Python.tester\" />\r\n      <item itemvalue=\"Python.controller\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.controller\" />\r\n        <item itemvalue=\"Python.hybrid_test_backend\" />\r\n        <item itemvalue=\"Python.client\" />\r\n        <item itemvalue=\"Python.server\" />\r\n        <item itemvalue=\"Python.tester\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"91da95a7-87d1-4534-8d3d-902312f1a94d\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1603337961417</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1603337961417</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Added fail state code as well as some Controller class functionality\">\r\n      <created>1611537816474</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1611537816474</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Added the state update method and thread.\">\r\n      <created>1611882057862</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1611882057862</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"3\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Added fail state code as well as some Controller class functionality\" />\r\n    <MESSAGE value=\"Added the state update method and thread.\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Added the state update method and thread.\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9ebcffdf0c4e5c26cc0824b8d06843a8d3087088)
+++ b/.idea/workspace.xml	(date 1612239464192)
@@ -20,7 +20,9 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="91da95a7-87d1-4534-8d3d-902312f1a94d" name="Default Changelist" comment="Added the state update method and thread.">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/source/controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/source/controller.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/source/hybrid_test_backend.py" beforeDir="false" afterPath="$PROJECT_DIR$/source/hybrid_test_backend.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -157,10 +159,10 @@
     </configuration>
     <list>
       <item itemvalue="Python.client" />
+      <item itemvalue="Python.controller" />
       <item itemvalue="Python.hybrid_test_backend" />
       <item itemvalue="Python.server" />
       <item itemvalue="Python.tester" />
-      <item itemvalue="Python.controller" />
     </list>
     <recent_temporary>
       <list>
